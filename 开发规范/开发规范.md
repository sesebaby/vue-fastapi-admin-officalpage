# AI 协作开发全链路规范

---

## 🚨 AI工程开发六大强制原则

### 📋 核心原则（每次行动前必须强制汇报反思）

#### 1. **TOKENS限制管理原则**
```yaml
核心要求:
  - 任务接收后立即估算完整执行所需的tokens数量
  - 明确计算每个子任务的预期tokens消耗
  - 最大可使用Token限制为50000 tokens
  - 向用户明确汇报：将在第X个任务后停止，需要新对话继续
  - 绝不尝试在单次会话中强行完成超出tokens限制的任务

危险行为识别:
  - ❌ 急于结束任务而频繁简化操作
  - ❌ 省略必要的验证步骤
  - ❌ 使用"快速"、"批量"等降低质量的方法
  - ❌ 创建临时或简化版本的文件/代码

执行要求:
  - 宁可分多次对话完成，也不能降低任何质量标准
  - 如发现tokens即将耗尽，立即停止并向用户说明需要新对话继续
```

#### 2. **绝不简化原则**
```yaml
核心要求:
  - 不创建任何简化版本或降低标准
  - 任何情况下都不允许进行简化操作
  - 必须逐项手动确认每个步骤

绝对禁止:
  - ❌ 任何包含"simple"、"basic"、"temp"、"quick"的文件名
  - ❌ 创建简化版本来绕过技术难题
  - ❌ 降低功能标准来快速完成
  - ❌ 省略必要的配置和验证步骤
```

#### 3. **测试驱动原则**
```yaml
核心要求:
  - 严格遵循TDD红-绿-重构循环
  - 测试先行，代码后行
  - 测试不可变，实现必须适应测试

绝对禁止:
  - ❌ 修改测试来适应实现
  - ❌ 因为实现困难而降低测试标准
  - ❌ 跳过红阶段直接写代码
  - ❌ 简化测试用例来避免复杂配置
```

#### 4. **质量优先原则**
```yaml
核心要求:
  - 完整实现每个功能，不使用占位符或TODO
  - 包含完整代码、错误处理、数据验证、文档注释
  - 测试覆盖率≥90%，包含边界条件和异常情况

绝对禁止:
  - ❌ 使用占位符或TODO标记
  - ❌ 省略错误处理和数据验证
  - ❌ 降低测试覆盖率标准
  - ❌ 跳过边界条件和异常情况测试
```

#### 5. **技术债务原则**
```yaml
核心要求:
  - 严格技术栈一致性，绝不新增技术债务，除非用户明确允许
  - 所有功能必须在现有技术栈内实现
  - 禁止引入新技术栈、框架、库

绝对禁止:
  - ❌ 未经用户授权引入新技术栈
  - ❌ 为了简化而使用不一致的技术方案
  - ❌ 创建技术债务来快速完成任务

```

#### 6. **文档驱动原则**
```yaml
核心要求:
  - 编写代码或测试发生错误时，必须使用Context7 MCP工具或web工具获取官方文档
  - 严格使用"正确版本"的官方文档，确保技术实现的准确性
  - 所有技术决策必须基于权威文档，而非推测或经验

强制使用工具的情况:
  - ✅ 代码编译失败或运行时错误
  - ✅ 测试用例执行失败
  - ✅ API调用返回意外结果
  - ✅ 配置文件格式错误
  - ✅ 依赖包版本冲突
  - ✅ 框架或库的使用方法不确定

"正确版本"文档判断标准:
  - 📋 版本号必须与项目中使用的版本完全匹配
  - 📋 文档来源必须是官方网站、GitHub官方仓库或官方API文档
  - 📋 优先级：官方文档 > 官方示例 > 社区文档 > 第三方教程
  - 📋 确认文档发布时间与技术版本发布时间一致
  - 📋 验证文档中的代码示例在当前版本中可正常运行

执行步骤:
  1. 识别错误类型和涉及的技术栈/框架/库
  2. 确定需要查询的具体技术点和版本号
  3. 使用Context7 MCP工具搜索对应的官方文档
  4. 如Context7无法找到，使用web工具搜索官方网站
  5. 验证文档版本与项目版本的匹配性
  6. 提取正确的实现方法和最佳实践
  7. 应用文档中的解决方案并验证效果

检查点:
  - □ 是否确认了技术栈的确切版本号？
  - □ 是否使用了官方文档而非第三方资料？
  - □ 是否验证了文档版本与项目版本的一致性？
  - □ 是否完整理解了官方推荐的实现方式？
  - □ 是否按照官方文档的标准格式和约定实现？

绝对禁止:
  - ❌ 基于记忆或经验猜测API用法
  - ❌ 使用过时版本或错误版本的文档
  - ❌ 参考非官方的第三方教程作为主要依据
  - ❌ 忽略官方文档中的警告和注意事项
  - ❌ 简化或修改官方推荐的实现方式
```

### 🔍 强制反思检查流程
**每次执行任务前必须输出以下反思标志：**
```
[TOKENS限制第一原则已反思] - 已评估tokens使用量，确认不会急于结束
[绝不简化第二原则已反思] - 确认不会创建任何简化版本或降低标准
[测试驱动第三原则已反思] - 确认严格遵循TDD红-绿-重构循环
[质量优先第四原则已反思] - 确认完整实现，不使用占位符或TODO
[技术债务第五原则已反思] - 确认了解技术栈一致性原则，绝不新增技术债务，除非用户允许
[文档驱动第六原则已反思] - 确认在代码或测试出错时必须使用Context7 MCP或web工具获取官方正确版本文档
```

### ⚠️ 违反后果
任何违反六大原则的行为（如急于结束、简化操作、省略步骤、不查阅官方文档）都被视为严重的工程质量事故，必须立即停止并重新开始。

---

## 1. 架构图先行：宏观到微观分层设计

### 📌 层级划分

- **Presentation Layer（表示层）**
  - 职责：UI 组件、页面路由、状态管理（Redux/Pinia/Vuex/zod）
  - 技术栈：React/Vue/Svelte + TS

- **Application / Service Layer（应用层/服务层）**
  - 职责：用例逻辑、服务编排、API 调用封装
  - 技术栈：NestJS、Spring Boot、ASP.NET Core

- **Domain Layer（领域层）**
  - 职责：实体、值对象、聚合根、领域服务
  - 实践：DDD、Ubiquitous Language

- **Infrastructure Layer（基础设施层）**
  - 职责：数据库、缓存、消息队列、第三方 API
  - 实践：ORM、数据库迁移脚本、外部集成适配器

### 📌 边界与依赖

- 仅暴露必要接口（API / 方法签名）
- 使用依赖倒置：上层依赖接口，接口由下层实现
- 依赖方向：用箭头标明 `Presentation → Application → Domain → Infrastructure`

### 📌 产物

- **绘图工具**：Mermaid、Draw.io、PlantUML
- **输出**：统一放在 `docs/architecture`，供 AI 和人共同查看

---

## 2. 文档先行：契约优先、代码后写

### ✅ API 契约

- 工具：OpenAPI（Swagger）/ GraphQL SDL
- 内容要求：
  - 路径、方法（GET/POST/PUT/DELETE）
  - 请求体、响应体的 JSON Schema
  - 字段描述（类型、是否必填、示例值）
  - 错误码定义及含义

- 前端/后端/测试共用同一份契约
- 使用 `OpenAPI Generator` / `GraphQL Codegen` 自动生成 TS 类型和客户端

### ✅ 领域数据模型

- 工具：ER 图、Class Diagram（Mermaid/Class UML）
- 必须包含：
  - 实体表关系（PK/FK）
  - 字段业务含义、取值范围、单位（如金额、时间）
  - 约束条件（唯一、非空、索引）

### ✅ 用户故事与接受标准

- 采用 Gherkin 格式，放 `docs/specs`
  ```gherkin
  Feature: 下单流程
    Scenario: 用户提交订单
      Given 用户已登录
      When 用户点击“提交订单”
      Then 创建一条 Order 记录，状态为“Pending”
## 3. 代码目录与模块化约定

### 📌 约定

- 每个服务/功能模块独立管理，契约文件放同级
- 公共类型、DTO、验证器统一放 `shared/`
- 基础设施（数据库、队列、API 网关）IaC 化管理，放 `infra/`
- 所有文档、示例、约束放 `docs/`，AI 与人类共享

---

## 4. 全链路强类型与静态检查

- **前端**：TypeScript（开启 `strict`），GraphQL Codegen / OpenAPI Generator 自动生成类型
- **后端**：C#（nullable enable）、Go（显式类型）、Java/Kotlin（严格模式）
- **类型共享**：通过 `shared/types` 保证 DTO、验证器一致
- **格式化**：
  - `ESLint` + `Prettier`：统一风格
  - 类型错误、未使用变量、隐式 any 一律禁止

---

## 5. 测试驱动 & 文档驱动开发（TDD/BDD）

### ✅ 测试先行

- 单元测试（Jest、xUnit、pytest）
- 集成测试（Supertest、Postman/Newman）
- E2E 测试（Cypress、Playwright）

### ✅ Gherkin 用例驱动

- 所有核心流程先写 Gherkin：
  ```gherkin
  Feature: 支付流程
    Scenario: 用户付款成功
      Given 用户已下单
      When 用户完成支付
      Then 订单状态更新为 “Paid”

### 🚨 TDD严格规范
**详细的TDD规范和反面教材请参考：[TDD严格规范.md](./TDD严格规范.md)**

**核心原则**：
- ✅ **测试先行，代码后行**
- ✅ **测试不可变，实现必须适应测试**
- ❌ **绝对禁止修改测试来适应实现**
- ❌ **绝对禁止因为实现困难而降低测试标准**

### 🚨 禁止简化操作严格规范

#### 📋 核心原则
**任何情况下都不允许进行简化操作，必须逐项手动确认每个步骤**

#### 🚫 绝对禁止的简化行为
```yaml
文件命名禁止:
  - ❌ 任何包含 "simple"、"basic"、"temp"、"quick" 的文件名
  - ❌ 任何包含 "test"、"demo"、"sample" 的临时文件
  - ❌ 任何暗示简化或临时性质的命名

实现禁止:
  - ❌ 创建简化版本来绕过技术难题
  - ❌ 降低功能标准来快速完成
  - ❌ 省略必要的配置和验证步骤
  - ❌ 使用占位符或TODO标记

测试禁止:
  - ❌ 简化测试用例来避免复杂配置
  - ❌ 降低测试覆盖率标准
  - ❌ 跳过边界条件和异常情况测试
  - ❌ 创建"基础版本"测试文件
```

#### 🚨 违规案例教训（真实反面教材）
```yaml
违规行为:
  案例: 创建 test_education_api_simple.py 文件
  违规性质: 明显违反"禁止简化操作"原则

错误思维根源:
  - 惰性思维：试图走捷径避免技术难题
  - 错误优先级：认为快速验证比严格遵循规范更重要
  - 规范理解不深：以为简化只是指省略步骤

正确做法应该是:
  - 深入分析技术问题根源
  - 逐项解决配置和环境问题
  - 实现完整、正确的解决方案
  - 绝不妥协质量标准
```

#### ✅ 正确的问题解决流程
```yaml
遇到技术困难时:
1. 深思熟虑分析:
   - 分析问题的根本原因
   - 评估解决方案的完整性
   - 确认是否符合规范要求

2. 逐项解决问题:
   - 不跳过任何必要步骤
   - 不降低任何质量标准
   - 不创建任何简化版本

3. 完整实现方案:
   - 包含所有必要的功能
   - 满足所有质量要求
   - 通过所有验证标准

4. 行动前反思检查:
   - 是否违反"禁止简化"原则？
   - 是否试图走捷径避免困难？
   - 是否降低了质量标准？
   - 文件命名是否暗示简化？
```

#### 📋 强制执行措施
```yaml
代码审查要求:
  - 任何包含简化标识的文件名都不允许提交
  - 任何降低标准的实现都必须重做
  - 任何试图绕过规范的行为都要立即纠正

自我检查清单:
  每次行动前必须问自己:
  - □ 这个文件名是否暗示简化？
  - □ 这个实现是否降低了标准？
  - □ 这个做法是否试图走捷径？
  - □ 这个方案是否完整解决问题？
```

## 6. Prompt 模板与 AI 使用规范

### ✅ 标准 Prompt 结构

使用固定模板，让 AI 理解上下文、约束和产出要求，降低偏差。

```text
背景：简要描述上下文和业务目标，可附文档/契约路径

契约：贴 OpenAPI / GraphQL SDL / ER 图 / UML 等片段，或提供文件路径

任务：要生成/修改的功能（例如：实现某接口、补充测试、生成 DTO）

质量要求：
- 格式化：ESLint + Prettier（前端）/ dotnet format（后端）
- 类型要求：TypeScript 严格模式 / C# nullable enable / Go 显式声明
- 注释：TSDoc / JSDoc / Swagger 注释齐全，字段含义完整
- 单元测试：覆盖率 ≥ 90% 且包含边界条件

示例 Prompt：
背景：Order 服务，契约见 `services/order/openapi.yaml`
任务：用 NestJS 实现 POST `/orders`、GET `/orders/{id}`
要求：
- 使用 class-validator 校验所有参数
- Jest 单元测试覆盖率 ≥ 95%
- 生成的代码符合 TSDoc 规范
推荐:
一次只做一件事，拆分成小任务，多轮生成
Prompt 中必须包含版本信息（契约/架构）
生成后对照文档核验，不可直接合并

## 7. 评审与自动化流程

### ✅ 小步拉取请求（PR）

- 每个 PR 只包含单一功能、单一用例或单一模块的增改
- 必须配套：
  - 生成的核心代码
  - 对应单元测试或集成测试
  - 契约文件或引用路径
  - Gherkin 场景（如有）
- 必须至少经过一轮人工 Code Review

### ✅ 静态分析 + 自动化校验

- **CI 阶段强制执行**：
  - 类型检查：TypeScript 严格模式、C# 可空检查、Go 显式类型
  - Lint：ESLint、Prettier、StyleCop、GolangCI-Lint
  - 单元测试 & 集成测试：覆盖率 ≥ 90%
  - 契约一致性：OpenAPI Diff、GraphQL Lint、Schema 校验
- 不通过即驳回，禁止合并到主干

### ✅ 防止 AI“偷偷发挥”

- 自动检测生成代码是否超出契约/文档定义
- 自动 diff 检查敏感逻辑变更
- 生产环境部署只允许完全通过审查与自动化的 PR

---

## 8. 关键点一览表

| 方法 | 目的 | 工具/实践 |
| ---- | ---- | ---------- |
| 架构图 | 明确分层、依赖方向 | Mermaid / Draw.io / PlantUML |
| 契约优先 | 统一前后端接口 | OpenAPI / GraphQL SDL |
| 强类型 | 避免误用、自动补全 | TS 严格模式、C#、Go + codegen |
| TDD/BDD | 用测试/用例驱动开发 | Jest、pytest、Cypress、Gherkin |
| Prompt 模板 | 上下文完整、可重复 | 标题 + 契约路径 + 任务 + 质量要求 |
| CI/CD | 自动化检查、持续部署 | GitHub Actions / GitLab CI |

---

## ✅ 总结

- **设计先行**：架构 → 契约 → 数据模型 → 用例
- **契约即代码**：前后端共用一份约束，自动生成
- **强类型守护**：全链路类型一致，错误拦截自动化
- **测试驱动**：每个功能点有 Gherkin 或单测先行
- **Prompt 标准化**：上下文、契约、质量要求一体
- **CI/CD 严把关**：类型、Lint、测试、契约一致性一步都不能少

---

> 📌 **此规范文件请保存为 `docs/AI_DEVELOPMENT_GUIDE.md`，团队与 AI 协作均须严格遵守！**
